generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mongodb"
  url      = env("DATABASE_URL")
}

enum Gender {
  MALE
  FEMALE
  NON_BINARY
}

enum Role {
  USER
  ADMIN
}

enum MediaType {
  IMAGE
  VIDEO
  VR_360
}

enum MediaCategory {
  AVATAR
  COVER
  GALLERY
  REVIEW_PHOTO
  OFFICIAL // For manually curated content
}

/**
 * -------------------------- USER ---------------------------
 */
model User {
  id               String    @id @default(auto()) @map("_id") @db.ObjectId
  /* ---- INFO ---- */
  email            String?   @unique
  role             Role      @default(USER)
  name             String?
  emailVerified    DateTime?
  passwordHash     String?
  profileCompleted Boolean   @default(false)

  /* ---- LOCATION ---- */
  currentLocation Json? // [lng, lat]
  currentCityId   String? @db.ObjectId
  currentCity     City?   @relation("CurrentLocation", fields: [currentCityId], references: [id])

 /* ---- TRAVELS ---- */
  visitedCountries String[] @default([])
    
    /* ---- TRAVEL HISTORY ---- */
  cityVisits CityVisit[]

  /* ---- AUTH ---- */
  accounts Account[]
  sessions Session[]

  /* ---- PROFILE ---- */
  profile      UserProfile?
  
  // Refactored Media Relations
  media        Media[] // Media uploaded by this user
  
  // Helper for quick avatar access (optional, can also query Media model directly)
  avatarUrl    String? 
  
 

  /* ---- FRIENDSHIP ---- */
  friendshipsRequested Friendship[] @relation("FriendshipsRequested")
  friendshipsReceived  Friendship[] @relation("FriendshipsReceived")

  /* ---- CHAT ---- */
  chats        ChatMember[]
  sentMessages Message[]    @relation("SentMessages")

  

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

/**
 * -------------------------- UNIFIED MEDIA ---------------------------
 * Replaces UserMedia. Handles all images/videos for Users, Places, Cities, etc.
 */
model Media {
  id       String        @id @default(auto()) @map("_id") @db.ObjectId
  url      String
  publicId String // Cloudinary/S3 ID
  
  type     MediaType     @default(IMAGE)
  category MediaCategory @default(GALLERY)

  metadata Json? // { width, height, blurHash, altText }

  // --- OWNERSHIP ---
  userId String? @db.ObjectId
  user   User?   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // --- ASSOCIATIONS (Where does this image appear?) ---
  // A media item usually belongs to one entity, but could technically belong to multiple if shared
  placeId String? @db.ObjectId
  place   Place?  @relation(fields: [placeId], references: [id])

  cityId String? @db.ObjectId
  city   City?   @relation(fields: [cityId], references: [id])
  
  countryId String? @db.ObjectId
  country   Country? @relation(fields: [countryId], references: [id])

  reviewId String? @db.ObjectId
  // review Review? @relation(...) // If you add reviews later

  createdAt DateTime @default(now())
  
  @@index([userId])
  @@index([placeId])
  @@index([cityId])
}

/**
 * -------------------------- USER PROFILE ---------------------------
 */
model UserProfile {
  id     String @id @default(auto()) @map("_id") @db.ObjectId
  userId String @unique @db.ObjectId
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  /* ---- INFO ---- */
  firstName   String?
  lastName    String?
  occupation  String?
  birthday    DateTime?
  description String?
  gender      Gender?

  /* ---- LANGUAGE ---- */
  languages String[] @default([])

  /* ---- HOME BASE ---- */
  homeBaseCityId String? @db.ObjectId
  homeBaseCity   City?   @relation("HomeBase", fields: [homeBaseCityId], references: [id])

  /* ---- TRAVEL PERSONA ---- */
  persona Json? // { dailyRhythm, travelStyle, interests }
  socials Json? // { instagram, tiktok }

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Account {
  id                String  @id @default(auto()) @map("_id") @db.ObjectId
  userId            String  @db.ObjectId
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @map("refresh_token")
  access_token      String? @map("access_token")
  expires_at        Int?    @map("expires_at")
  token_type        String?
  scope             String?
  id_token          String? @map("id_token")
  session_state     String? @map("session_state")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@unique([provider, providerAccountId])
  @@index([userId])
}

model Session {
  id           String   @id @default(auto()) @map("_id") @db.ObjectId
  sessionToken String   @unique
  userId       String   @db.ObjectId
  expires      DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  id         String   @id @default(auto()) @map("_id") @db.ObjectId
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model Country {
  id            String   @id @default(auto()) @map("_id") @db.ObjectId
  cca3          String   @unique // "THA", "DEU" (Primary lookup key)
  code          String   // "TH", "DE" (ISO 3166-1 alpha-2)
  name          String
  officialName  String?
  imageHeroUrl  String?
  isUnMember Boolean?
  isIndependent Boolean?

  population    Int?
  areaKm2       Float?
  flags         Json?    // { png, svg, alt }
  borders       String[] // cca3 codes for "Nearby" features
  idd Json?
  tld Json?

  // MongoDB Geospatial Standard
  // Index this in DB: db.Country.createIndex({ "coords": "2dsphere" })
  coords        Json?    // { type: "Point", coordinates: [lng, lat] }
  maps          Json?    // { googleMaps, openStreetMaps }

  // 1. LOGISTICS & UTILITIES
  logistics     Json?    /* {
      car: { side: "left", signs: ["T"] },
      plugs: ["A", "B", "C"], // Standardized plug types
      voltage: 220,
      timezones: ["UTC+07:00"],
      startOfWeek: "monday"
  } */

  // 2. FINANCE & BUDGET
  finance       Json?    /* {
      currency: { code: "THB", symbol: "à¸¿", name: "Thai Baht" },
      avgDailyCost: 45, // Numeric for filtering/sorting
      cashCulture: { tipping: "10%", atmAvailability: "High" }
  } */

  // 3. SAFETY & EMERGENCY
  safety        Json?    /* {
      overallScore: 4.5,
      soloFemaleFriendly: 5, // 1-5 rating
      crimeLevel: "Low",
      scams: [{ type: "Tuk-Tuk", tip: "..." }]
  } */

  emergency     Json?    // { police: "191", touristPolice: "1155" }

  // 4. HEALTH & MEDICAL
  health        Json?    /* {
      tapWaterSafe: false,
      vaccines: ["Hepatitis A", "Typhoid"],
      medicalStandard: "International (Cities)"
  } */

  // 5. SEASONS LOGIC (Improved)
  seasons       Json?    /* {
      peakMonths: [11, 12, 1, 2], // Nov to Feb
      shoulderMonths: [3, 4, 10],
      note: "Avoid monsoon in September"
  } */

  // 6. LANGUAGES & PHRASES
  // Structure: { official: string[], spoken: string[], nativeName: string, codes: string[] }
  languages     Json?
  commonPhrases Json?    // Array: [{ label: "Hello", category: "Basics", audioUrl: "..." }]

  visaInfo Json? /* {
  requiresVisa: boolean,
  type: "Visa Free" | "e-Visa" | "Visa on Arrival" | "Embassy Visa",
  durationDays: 30,
  notes: "Israeli passport holders...",
  processingTime: "Instant" | "3-5 days",
  cost: { amount: 0, currency: "USD" }
} */


  // Geography & Relations
  region        String?
  subRegion     String?
  capitalName   String?
  capitalId     String?  @unique @db.ObjectId
  capitalCity   City?    @relation("CountryCapital", fields: [capitalId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  
  // Relations
  cities        City[]
  places        Place[]
  media         Media[]

  needsReview   Boolean  @default(false)
  autoCreated   Boolean  @default(false)

  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@index([coords], map: "coords_2dsphere")
}

/**
 * ------------------------- CITY -------------------------
 */
model City {
  id           String   @id @default(auto()) @map("_id") @db.ObjectId
  cityId       String   @unique // "bangkok"
  name         String
  countryRefId String?  @db.ObjectId
  country      Country? @relation(fields: [countryRefId], references: [id], onDelete: Cascade)

  isCapital Boolean @default(false)

  // Geo
  coords      Json // GeoJSON Point
  radiusKm    Int     @default(30)
  timeZone    String?
  boundingBox Json? // { sw: [lng, lat], ne: [lng, lat] } - Crucial for map zoom

  // Media
  imageHeroUrl String?
  media        Media[]

  // Meta
  state         String?
  district      String?
  population    Int?
  bestSeason    String?
  idealDuration String?
  safety        String?
  neighborhoods String[] @default([])
  budget        Json?
  gettingAround Json?

  places Place[]

  // User Relations
  usersHomeBase    UserProfile[] @relation("HomeBase")
  usersCurrentCity User[]        @relation("CurrentLocation")
  
  // Travel History
  cityVisits CityVisit[]

  autoCreated Boolean @default(false)
  needsReview Boolean @default(false)

  capitalOf Country? @relation("CountryCapital")

  @@index([countryRefId])
}

/**
 * ------------------------- CITY VISIT (Travel History) -------------------------
 */
model CityVisit {
  id String @id @default(auto()) @map("_id") @db.ObjectId

  userId String @db.ObjectId
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  cityId String @db.ObjectId
  city   City   @relation(fields: [cityId], references: [id], onDelete: Cascade)

  startDate DateTime @default(now())
  endDate   DateTime? // null = current/active visit

  // Optional: store entry/exit coordinates for detailed tracking
  entryCoords Json? // GeoJSON Point { type: "Point", coordinates: [lng, lat] }
  exitCoords  Json? // GeoJSON Point

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId, endDate]) // Query for current location (endDate = null)
  @@index([userId, startDate]) // Query travel history chronologically
  @@index([cityId])
}

/**
 * ------------------------- PLACE (Formerly Activity) -------------------------
 */
model Place {
  id      String @id @default(auto()) @map("_id") @db.ObjectId
  slug    String @unique // "chatuchak-weekend-market"
  name    String
  altName String?

  // Relations
  cityRefId String @db.ObjectId
  city      City   @relation(fields: [cityRefId], references: [id], onDelete: Cascade)

  countryRefId String?  @db.ObjectId
  country      Country? @relation(fields: [countryRefId], references: [id], onDelete: Cascade)

  // Classification
  type       String // "RESTAURANT", "LANDMARK", "MUSEUM"
  categories String[] // ["street-food", "history"]
  mapIcon    String?  // "cutlery", "camera", "bed" - For map rendering

  // Location
  address      String?
  coords       Json // GeoJSON { type: "Point", coordinates: [lng, lat] }
  timeZone     String?
  neighborhood String?

  // Contact / Info (New Traveler Fields)
  websiteUrl    String?
  phoneNumber   String?
  googlePlaceId String? @unique
  
  // Ops
  openingHours         Json? // Structured weekly hours
  isPermanentlyClosed  Boolean @default(false)
  
  bestTimeToVisit      String?
  typicalVisitDuration String?

  // Social Proof (Aggregated)
  rating      Float? @default(0.0)
  reviewCount Int    @default(0)

  // Price
  entryPrice Json? // { currencyCode, range: "$-$$$$", exact: 100 }

  // UX & Vibe
  amenities     String[] // "wifi", "ac", "parking"
  vibe          String[] // "quiet", "crowded", "touristy"
  accessibility String?
  safetyNotes   String?
  
  // Media
  imageHeroUrl String? // Quick access cover
  media        Media[] // Full gallery

  // CMS Content
  summary    String?
  highlights String[]
  tags       String[]

  autoCreated Boolean @default(false)
  needsReview Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([cityRefId])
  @@index([countryRefId])
  @@index([type])
  @@index([coords]) // Geo index for "places near me"
}



/**
 * ------------------------- FRIENDSHIP -------------------------
 */
enum FriendStatus {
  PENDING
  ACCEPTED
  DENIED
  BLOCKED
}

model Friendship {
  id String @id @default(auto()) @map("_id") @db.ObjectId

  requesterId String       @db.ObjectId
  addresseeId String       @db.ObjectId
  status      FriendStatus @default(PENDING)

  blockedById String? @db.ObjectId

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  requester User @relation("FriendshipsRequested", fields: [requesterId], references: [id], onDelete: Cascade)
  addressee User @relation("FriendshipsReceived", fields: [addresseeId], references: [id], onDelete: Cascade)

  @@unique([requesterId, addresseeId])
  @@index([requesterId])
  @@index([addresseeId])
  @@index([status])
}

/**
 * ---------------------------- CHAT -----------------------------
 */

model Chat {
  id         String  @id @default(auto()) @map("_id") @db.ObjectId
  isGroup    Boolean @default(false)
  groupName  String?
  groupImage String?

  members  ChatMember[]
  messages Message[]    @relation("ChatMessages")

  lastMessageId String?  @db.ObjectId
  lastMessage   Message? @relation("ChatLastMessage", fields: [lastMessageId], references: [id], onDelete: NoAction, onUpdate: NoAction)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model ChatMember {
  id     String @id @default(auto()) @map("_id") @db.ObjectId
  chatId String @db.ObjectId
  userId String @db.ObjectId

  lastReadAt DateTime?

  chat Chat @relation(fields: [chatId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([chatId, userId])
  @@index([userId])
}

model Message {
  id       String   @id @default(auto()) @map("_id") @db.ObjectId
  chatId   String   @db.ObjectId
  senderId String   @db.ObjectId
  content  String
  
  readBy   String[] @db.ObjectId

  chat   Chat @relation("ChatMessages", fields: [chatId], references: [id], onDelete: Cascade)
  sender User @relation("SentMessages", fields: [senderId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  chatLastMessage Chat[] @relation("ChatLastMessage")

  @@index([chatId])
  @@index([senderId])
}

/**
 * ---------------------------- SEARCH -----------------------------
 */
model SearchEvent {
  id                 String   @id @default(auto()) @map("_id") @db.ObjectId
  userId             String?
  sessionId          String
  searchQuery        String
  timestamp          DateTime @default(now())
  resultCount        Int
  clickedResultIndex Int?
  pagePath           String?
}